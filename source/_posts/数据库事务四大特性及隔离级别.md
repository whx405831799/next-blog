title: 数据库事务四大特性及隔离级别
date: 2017/04/23 22:56:31
categories:
- 数据库
tags:
- mysql
- 事务
---
## 1.事物四大特性ACID
- 原子性Atomicity:原子性是指一个事务包含的所有操作要么全部成功，要么全部失败回滚。
- 一致性Consistency:一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

```
但是事务可以不同程度的一致性：
 强一致性：读操作可以立即读到提交的更新操作。
 弱一致性：提交的更新操作，不一定立即会被读操作读到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。
 最终一致性：是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样的值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等。
 其他一致性变体还有：
 单调一致性：如果一个进程已经读到一个值，那么后续不会读到更早的值。
 会话一致性：保证客户端和服务器交互的会话过程中，读操作可以读到更新操作后的最新值。
```
- 隔离性Isolation:并发事务之间互相影响的程度，比如一个事务会不会读取到另一个未提交的事务修改的数据。比如一个事务会不会读取到另一个未提交的事务修改的数据。在工程实践中，为了性能的考虑会对隔离性进行折中，下文会介绍几种隔离级别。
- 持久性durability：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

## 2.脏读幻读不可重复读
如果不考虑事务的隔离性，会发生的几种问题：
- 脏读：事务A修改了一个数据，但未提交，事务B读到了事务A未提交的更新结果，如果事务A提交失败，事务B读到的就是脏数据。
- 不可重复读：在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务B在事务A提交前读到的结果，和提交后读到的结果可能不同。不可重复读出现的原因就是事务并发修改记录，要避免这种情况，最简单的方法就是对要修改的记录加锁，这回导致锁竞争加剧，影响性能。另一种方法是通过MVCC可以在无锁的情况下，避免不可重复读。
- 幻读：在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读。

## 3.四种隔离级别
从低到高：
- Read Uncommitted：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。
- Read Committed：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。
- Repeated Read：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。
- Serialization：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。
